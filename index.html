<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Tropical Left-Fall Bridge Game</title>
<style>
  body {
    margin: 0;
    background: linear-gradient(#ffcc70, #ffecd2);
    overflow: hidden;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = window.innerWidth;
let H = window.innerHeight;
canvas.width = W;
canvas.height = H;

const GROUND_Y = H * 0.75;

const colors = {
  skyTop: '#ffcc70',
  skyBottom: '#ffecd2',
  pillar: '#c2b280',
  pillarTop: '#e6d8ad',
  stick: '#5b3a29',
  player: '#2b2b2b',
  accent: '#ff6f61',
  island: '#d2b48c',
  islandEdge: '#c2a178',
  water: '#00bcd4',
  palmTrunk: '#8b5a2b',
  palmLeaves: '#228b22'
};

let platforms = [];
let stick = { baseX: 0, length: 0, angle: Math.PI, rotateSpeed: Math.PI, growing: false };
let player = { x: 0, y: 0, size: 20, walking: false };
let state = 'waiting';
let score = 0;

function init() {
  platforms = [
    { x: 200, w: 60 }, // starting island
    { x: 50, w: 60 }   // target island to the left
  ];
  stick.baseX = platforms[0].x; // left edge of starting island
  stick.length = 0;
  stick.angle = Math.PI; // straight up, facing left
  player.x = platforms[0].x; // player at left edge
  player.y = GROUND_Y - player.size;
  score = 0;
  state = 'waiting';
}
init();

function drawPlatform(p) {
  const top = GROUND_Y - 100;
  ctx.fillStyle = colors.island;
  ctx.fillRect(p.x, top, p.w, 100);
  ctx.fillStyle = colors.islandEdge;
  ctx.fillRect(p.x, GROUND_Y, p.w, H - GROUND_Y);

  // Palm tree
  ctx.fillStyle = colors.palmTrunk;
  ctx.fillRect(p.x + p.w/2 - 2, top - 40, 4, 40);
  ctx.fillStyle = colors.palmLeaves;
  for (let i = 0; i < 5; i++) {
    ctx.beginPath();
    ctx.ellipse(p.x + p.w/2, top - 40, 20, 8, (Math.PI * 2 / 5) * i, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawStick() {
  ctx.save();
  ctx.translate(stick.baseX, GROUND_Y - 100);
  ctx.rotate(stick.angle);
  ctx.fillStyle = colors.stick;
  ctx.fillRect(0, -2, stick.length, 4);
  ctx.restore();
}

function drawPlayer() {
  ctx.fillStyle = colors.player;
  ctx.fillRect(player.x, player.y, player.size, player.size);
  ctx.fillStyle = colors.accent;
  ctx.fillRect(player.x, player.y, player.size, 5);
}

function draw() {
  // Sky
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, colors.skyTop);
  grad.addColorStop(1, colors.skyBottom);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Water
  ctx.fillStyle = colors.water;
  ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);

  // Platforms
  platforms.forEach(drawPlatform);

  // Stick
  drawStick();

  // Player
  drawPlayer();

  // Score
  ctx.fillStyle = '#000';
  ctx.font = '20px sans-serif';
  ctx.fillText('Score: ' + score, 20, 30);
}

function update(dt) {
  if (state === 'growing') {
    stick.length += 200 * dt;
  } else if (state === 'rotating') {
    stick.angle -= stick.rotateSpeed * dt;
    if (stick.angle <= Math.PI / 2) {
      stick.angle = Math.PI / 2;
      const endX = stick.baseX - stick.length;
      const target = platforms[1];
      const success = endX >= target.x && endX <= target.x + target.w;
      state = 'walking';
      player.walking = true;
      player.toX = success ? target.x : endX;
      player.speed = 200;
      player.success = success;
    }
  } else if (state === 'walking') {
    if (player.x > player.toX) {
      player.x -= player.speed * dt;
    } else {
      if (player.success) {
        score++;
        const dx = 200 - platforms[0].x; // shift so new start island is at x=200
        platforms.forEach(p => p.x += dx);
        stick.baseX += dx;
        player.x += dx;
        platforms.shift();
        const last = platforms[platforms.length - 1];
        const gap = 100 + Math.random() * 200;
        const w = 50 + Math.random() * 50;
        platforms.push({ x: last.x - gap - w, w });
        stick.length = 0;
        stick.angle = Math.PI;
        stick.baseX = platforms[0].x;
        state = 'waiting';
      } else {
        state = 'falling';
      }
    }
  } else if (state === 'falling') {
    player.y += 300 * dt;
    if (player.y > H) {
      init();
    }
  }
}

let lastTime = null;
function loop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
loop();

window.addEventListener('mousedown', () => {
  if (state === 'waiting') {
    state = 'growing';
  }
});
window.addEventListener('mouseup', () => {
  if (state === 'growing') {
    state = 'rotating';
  }
});
window.addEventListener('resize', () => {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
});
</script>
</body>
</html>
