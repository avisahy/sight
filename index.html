<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Tropical Right-Fall Bridge Game with Waves, Player Fall & Splash</title>
<style>
  body {
    margin: 0;
    background: linear-gradient(#ffcc70, #ffecd2);
    overflow: hidden;
  }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let W = window.innerWidth;
let H = window.innerHeight;
canvas.width = W;
canvas.height = H;

let GROUND_Y = H * 0.75;

const colors = {
  skyTop: '#ffcc70',
  skyBottom: '#ffecd2',
  stick: '#5b3a29',
  player: '#2b2b2b',
  accent: '#ff6f61',
  island: '#d2b48c',
  islandEdge: '#c2a178',
  water: '#00bcd4',
  palmTrunk: '#8b5a2b',
  palmLeaves: '#228b22',
  wave: 'rgba(255,255,255,0.3)'
};

let platforms = [];
let stick = { baseX: 0, length: 0, angle: 0, rotateSpeed: Math.PI };
let player = { x: 0, y: 0, size: 20, walking: false, falling: false, vy: 0 };
let state = 'waiting';
let score = 0;
let waveOffset = 0;
let splashes = [];
let failTimer = 0;

function init() {
  platforms = [
    { x: 50, w: 60 },   // start island (left)
    { x: 200, w: 60 }   // target island (right)
  ];
  stick.baseX = platforms[0].x + platforms[0].w; // right edge of start island
  stick.length = 0;
  stick.angle = 0; // vertical
  player.x = platforms[0].x + platforms[0].w - player.size; // stand at right edge
  player.y = (GROUND_Y - 100) - player.size; // on top of island
  player.walking = false;
  player.falling = false;
  player.vy = 0;
  splashes = [];
  failTimer = 0;
  score = 0;
  state = 'waiting';
}
init();

function drawPlatform(p) {
  const top = GROUND_Y - 100;
  ctx.fillStyle = colors.island;
  ctx.fillRect(p.x, top, p.w, 100);
  ctx.fillStyle = colors.islandEdge;
  ctx.fillRect(p.x, GROUND_Y, p.w, H - GROUND_Y);

  // Palm tree
  ctx.fillStyle = colors.palmTrunk;
  ctx.fillRect(p.x + p.w / 2 - 2, top - 40, 4, 40);
  ctx.fillStyle = colors.palmLeaves;
  for (let i = 0; i < 5; i++) {
    ctx.beginPath();
    ctx.ellipse(p.x + p.w / 2, top - 40, 20, 8, (Math.PI * 2 / 5) * i, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawStick() {
  ctx.save();
  ctx.translate(stick.baseX, GROUND_Y - 100);
  ctx.rotate(stick.angle);
  ctx.fillStyle = colors.stick;
  ctx.fillRect(0, -2, stick.length, 4);
  ctx.restore();
}

function drawPlayer() {
  ctx.fillStyle = colors.player;
  ctx.fillRect(player.x, player.y, player.size, player.size);
  ctx.fillStyle = colors.accent;
  ctx.fillRect(player.x, player.y, player.size, 5);
}

function drawWaves() {
  ctx.fillStyle = colors.water;
  ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);

  ctx.strokeStyle = colors.wave;
  ctx.lineWidth = 2;
  const waveHeight = 8;
  const waveLength = 50;
  const speed = 2;

  waveOffset += speed; // subtle, frame-based
  ctx.beginPath();
  for (let x = 0; x <= W; x++) {
    const y = GROUND_Y + Math.sin((x + waveOffset) / waveLength) * waveHeight;
    if (x === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
}

function drawSplashes() {
  splashes.forEach(s => {
    ctx.beginPath();
    ctx.arc(s.x, s.y, 3, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
    ctx.fill();
  });
}

function draw() {
  // Sky
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, colors.skyTop);
  grad.addColorStop(1, colors.skyBottom);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Water
  drawWaves();

  // World
  platforms.forEach(drawPlatform);
  drawStick();
  drawPlayer();
  drawSplashes();

  // UI
  ctx.fillStyle = '#000';
  ctx.font = '20px sans-serif';
  ctx.fillText('Score: ' + score, 20, 30);
}

function update(dt) {
  if (state === 'growing') {
    stick.length += 200 * dt;
  } else if (state === 'rotating') {
    stick.angle += stick.rotateSpeed * dt; // rotate clockwise
    if (stick.angle >= Math.PI / 2) {
      stick.angle = Math.PI / 2;
      const endX = stick.baseX + stick.length;
      const target = platforms[1];
      const success = endX >= target.x && endX <= target.x + target.w;
      state = 'walking';
      player.walking = true;
      player.toX = success ? target.x + target.w - player.size : endX - player.size;
      player.speed = 200;
      player.success = success;
    }
  } else if (state === 'walking') {
    if (player.x < player.toX) {
      player.x += player.speed * dt;
    } else {
      if (player.success) {
        score++;
        const dx = 50 - platforms[0].x; // keep start island at x=50
        platforms.forEach(p => p.x += dx);
        stick.baseX += dx;
        player.x += dx;

        platforms.shift();
        const last = platforms[platforms.length - 1];
        const gap = 100 + Math.random() * 200;
        const w = 50 + Math.random() * 50;
        platforms.push({ x: last.x + last.w + gap, w });

        stick.length = 0;
        stick.angle = 0;
        stick.baseX = platforms[0].x + platforms[0].w;
        state = 'waiting';
      } else {
        state = 'stick-falling';
        player.falling = true;
        player.vy = 0;
        failTimer = 0;
      }
    }
  } else if (state === 'stick-falling') {
    stick.angle += stick.rotateSpeed * dt;
    failTimer += dt;

    if (player.falling) {
      // Slide along the stick and then fall
      player.x += Math.cos(stick.angle) * 2;
      player.y += Math.sin(stick.angle) * 2;
      player.vy += 500 * dt;     // gravity
      player.y += player.vy * dt;

      if (player.y >= GROUND_Y && splashes.length === 0) {
        createSplash(player.x + player.size / 2, GROUND_Y);
      }
    }

    // Move on after rotation completes or timeout (safety)
    if (stick.angle >= Math.PI || failTimer > 1.5) {
      state = 'falling';
    }
  } else if (state === 'falling') {
    player.vy += 800 * dt; // faster gravity so we don't hang
    player.y += player.vy * dt;
    if (player.y > H + 50) {
      init();
    }
  }

  // Splash particles
  splashes.forEach(s => {
    s.x += s.vx * dt;
    s.y += s.vy * dt;
    s.vy += 300 * dt;
    s.alpha -= 1.5 * dt;
  });
  splashes = splashes.filter(s => s.alpha > 0);
}

function createSplash(x, y) {
  for (let i = 0; i < 8; i++) {
    const angle = Math.random() * Math.PI;
    const speed = 100 + Math.random() * 100;
    splashes.push({
      x,
      y,
      vx: Math.cos(angle) * speed,
      vy: -Math.sin(angle) * speed,
      alpha: 1
    });
  }
}

let lastTime = 0;
function loop(t) {
  if (!lastTime) lastTime = t;
  const dt = (t - lastTime) / 1000;
  lastTime = t;

  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Input (mouse + touch)
function pressStart() {
  if (state === 'waiting') state = 'growing';
}
function pressEnd() {
  if (state === 'growing') state = 'rotating';
}
window.addEventListener('mousedown', pressStart);
window.addEventListener('mouseup', pressEnd);
window.addEventListener('touchstart', e => { e.preventDefault(); pressStart(); }, { passive: false });
window.addEventListener('touchend', e => { e.preventDefault(); pressEnd(); }, { passive: false });

// Resize
window.addEventListener('resize', () => {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
  GROUND_Y = H * 0.75;
});
</script>
</body>
</html>
